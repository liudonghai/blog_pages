<!DOCTYPE html>
<html>
<head>
  <meta name="baidu-site-verification" content="4zZom2xGSI" />
  <meta charset="utf-8">
  
  <title>MFC文件操作 | liudonghai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文记录了MFC中常见的文件相关操作 1.文件的查找&amp;emsp;CFileFind是为另两类查找特殊服务器设计的MFC类的基类，CGopherFileFind在Gopher服务器上工作，CFtpFileFind在FTP服务器上工作，这些类为用户查找文件提供了一种无缝机制，与服务器协议、文件类型、地点、本地机器或远程服务器无关。 12345678CString strFileTitle;CFileF">
<meta property="og:type" content="article">
<meta property="og:title" content="MFC文件操作">
<meta property="og:url" content="http://yoursite.com/2017/07/30/blog_md/MFC文件操作/index.html">
<meta property="og:site_name" content="liudonghai">
<meta property="og:description" content="本文记录了MFC中常见的文件相关操作 1.文件的查找&amp;emsp;CFileFind是为另两类查找特殊服务器设计的MFC类的基类，CGopherFileFind在Gopher服务器上工作，CFtpFileFind在FTP服务器上工作，这些类为用户查找文件提供了一种无缝机制，与服务器协议、文件类型、地点、本地机器或远程服务器无关。 12345678CString strFileTitle;CFileF">
<meta property="og:updated_time" content="2017-07-30T15:38:26.808Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MFC文件操作">
<meta name="twitter:description" content="本文记录了MFC中常见的文件相关操作 1.文件的查找&amp;emsp;CFileFind是为另两类查找特殊服务器设计的MFC类的基类，CGopherFileFind在Gopher服务器上工作，CFtpFileFind在FTP服务器上工作，这些类为用户查找文件提供了一种无缝机制，与服务器协议、文件类型、地点、本地机器或远程服务器无关。 12345678CString strFileTitle;CFileF">
  
    <link rel="alternate" href="/atom.xml" title="liudonghai" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">liudonghai</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-blog_md/MFC文件操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/30/blog_md/MFC文件操作/" class="article-date">
  <time datetime="2017-07-30T14:52:54.371Z" itemprop="datePublished">2017-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MFC文件操作
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文记录了MFC中常见的文件相关操作</p>
<h1 id="1-文件的查找"><a href="#1-文件的查找" class="headerlink" title="1.文件的查找"></a>1.文件的查找</h1><p>&emsp;CFileFind是为另两类查找特殊服务器设计的MFC类的基类，CGopherFileFind在Gopher服务器上工作，CFtpFileFind在FTP服务器上工作，这些类为用户查找文件提供了一种无缝机制，与服务器协议、文件类型、地点、本地机器或远程服务器无关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CString strFileTitle;</div><div class="line">CFileFind finder;</div><div class="line">BOOL bWorking = finder.FindFile(<span class="string">"C:\windows\sysbkup\*.cab"</span>);</div><div class="line"><span class="keyword">if</span>(bWorking)</div><div class="line">&#123;</div><div class="line">	bWorking=finder.FindNextFile();</div><div class="line">	strFileTitle=finder.GetFileTitle();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　2．文件的打开/保存对话框<br>　　让用户选择文件进行打开和存储操作时，就要用到文件打开/保存对话框。MFC的类CFileDialog用于实现这种功能。使用CFileDialog声明一个对象时，第一个BOOL型参数用于指定文件的打开或保存，当为TRUE时将构造一个文件打开对话框，为FALSE时构造一个文件保存对话框。<br>　　在构造CFileDialog对象时，如果在参数中指定了OFN_ALLOWMULTISELECT风格，则在此对话框中可以进行多选操作。此时要重点注意为此CFileDialog对象的m_ofn.lpstrFile分配一块内存，用于存储多选操作所返回的所有文件路径名，如果不进行分配或分配的内存过小就会导致操作失败。下面这段程序演示了文件打开对话框的使用方法。</p>
<p>　　CFileDialog mFileDlg(TRUE,NULL,NULL,OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_ALLOWMULTISELECT,<br>　　“All Files (<em>.</em>)|<em>.</em>||”,AfxGetMainWnd());<br>　　CString str(“ “,10000);<br>　　mFileDlg.m_ofn.lpstrFile=str.GetBuffer(10000);<br>　　str.ReleaseBuffer();<br>　　POSITION mPos=mFileDlg.GetStartPosition();<br>　　CString pathName(“ “,128);<br>　　CFileStatus status;<br>　　while(mPos!=NULL)<br>　　{<br>　　pathName=mFileDlg.GetNextPathName(mPos);<br>　　CFile::GetStatus( pathName, status );<br>　　}</p>
<p>　　3．文件的读写<br>　　文件的读写非常重要，下面将重点进行介绍。文件读写的最普通的方法是直接使用CFile进行，如文件的读写可以使用下面的方法：<br>　　//对文件进行读操作<br>　　<br>char sRead[2];<br>　　CFile mFile(_T(“user.txt”),CFile::modeRead);<br>　　if(mFile.GetLength()&lt;2)<br>　　return;<br>　　mFile.Read(sRead,2);<br>　　mFile.Close();<br>　　//对文件进行写操作<br>　　CFile mFile(_T(“user.txt “), CFile::modeWrite|CFile::modeCreate);<br>　　mFile.Write(sRead,2);<br>　　mFile.Flush();<br>　　mFile.Close();</p>
<p>　　虽然这种方法最为基本，但是它的使用繁琐，而且功能非常简单。我向你推荐的是使用CArchive，它的使用方法简单且功能十分强大。首先还是用CFile声明一个对象，然后用这个对象的指针做参数声明一个CArchive对象，你就可以非常方便地存储各种复杂的数据类型了。它的使用方法见下例。<br>　　<br>//对文件进行写操作<br>　　CString strTemp;<br>　　CFile mFile;<br>　　mFile.Open(“d:\dd\try.TRY”,CFile::modeCreate|CFile::modeNoTruncate|CFile::modeWrite);<br>　　CArchive ar(&amp;mFile,CArchive::store);<br>　　ar&lt;&lt;　　ar.Close();<br>　　mFile.Close();<br>　　//对文件进行读操作<br>　　CFile mFile;<br>　　if(mFile.Open(“d:\dd\try.TRY”,CFile::modeRead)==0)<br>　　return;<br>　　CArchive ar(&amp;mFile,CArchive::load);<br>　 　ar&gt;&gt;strTemp;<br>    　 ar.Close();<br>　　mFile.Close();</p>
<p>　　CArchive的 &lt;&lt; 和&gt;&gt; 操作符用于简单数据类型的读写，对于CObject派生类的对象的存取要使用ReadObject()和WriteObject()。使用CArchive的ReadClass()和WriteClass()还可以进行类的读写，如：<br>　　//存储CAboutDlg类<br>　　ar.WriteClass(RUNTIME_CLASS(CAboutDlg));<br>　　//读取CAboutDlg类<br>　　CRuntimeClass<em> mRunClass=ar.ReadClass();<br>　　//使用CAboutDlg类<br>　　CObject</em> pObject=mRunClass-&gt;CreateObject();<br>    　　((CDialog* )pObject)-&gt;DoModal();<br>　　虽然VC提供的文档/视结构中的文档也可进行这些操作，但是不容易理解、使用和管理，因此虽然很多VC入门的书上花费大量篇幅讲述文档/视结构，但我建议你最好不要使用它的文档。关于如何进行文档/视的分离有很多书介绍，包括非常著名的《Visual C++ 技术内幕》。<br>　　如果你要进行的文件操作只是简单的读写整行的字符串，我建议你使用CStdioFile，用它来进行此类操作非常方便，如下例。<br>　　CStdioFile mFile;<br>　　CFileException mExcept;<br>　　mFile.Open( “d:\temp\aa.bat”, CFile::modeWrite, &amp;mExcept);<br>　　CString string=”I am a string.”;<br>　　mFile.WriteString(string);<br>　　mFile.Close();</p>
<p>追加到原有txt文件尾</p>
<pre><code>mFile.Open(temptxt,CFile::modeCreate|CFile::modeWrite|CFile::modeNoTruncate);
</code></pre><p> if(mFile==NULL)<br>  return false;<br> mFile.SeekToEnd();<br> mFile.WriteString(s);</p>
<p> file.Close();<br>　4．临时文件的使用</p>
<p>　　正规软件经常用到临时文件，你经常可以会看到C:WindowsTemp目录下有大量的扩展名为tmp的文件，这些就是程序运行是建立的临时文件。临时文件的使用方法基本与常规文件一样，只是文件名应该调用函数GetTempFileName()获得。它的第一个参数是建立此临时文件的路径，第二个参数是建立临时文件名的前缀，第四个参数用于得到建立的临时文件名。得到此临时文件名以后，你就可以用它来建立并操作文件了，如：<br>　　char szTempPath[_MAX_PATH],szTempfile[_MAX_PATH];<br>　　GetTempPath(_MAX_PATH, szTempPath);<br>　　GetTempFileName(szTempPath,<em>T (“my</em>“),0,szTempfile);<br>　　CFile m_tempFile(szTempfile,CFile:: modeCreate|CFile:: modeWrite);<br>　　char m_char=’a’;<br>　　m_tempFile.Write(&amp;m_char,2);<br>　　m_tempFile.Close();<br>　　5．文件的复制、删除等<br>　　MFC中没有提供直接进行这些操作的功能，因而要使用SDK。SDK中的文件相关函数常用的有CopyFile()、CreateDirectory()、DeleteFile()、MoveFile()。它们的用法很简单，可参考MSDN。</p>
<p>1,判断文件是否存在<br>    access(filename,mode);<br>2,对于不同用途又不同的文件操作,其中API函数CreateFile()也是比较有用处理方式,对于巨型文件很合适的其他的楼上的大都说了,不重复了.</p>
<p>[1]显示对话框，取得文件名</p>
<p>CString FilePathName;<br>CFileDialog dlg(TRUE);///TRUE为OPEN对话框，FALSE为S<em>*</em>E AS对话框<br>if (dlg.DoModal() == IDOK)<br>    FilePathName=dlg.GetPathName();</p>
<p>相关信息：CFileDialog 用于取文件名的几个成员函数：<br>假如选择的文件是C:WINDOWSTEST.EXE<br>则(1)GetPathName();取文件名全称，包括完整路径。取回C:WINDOWSTEST.EXE<br>(2)GetFileTitle();取文件全名：TEST.EXE<br>(3)GetFileName();取回TEST<br>(4)GetFileExt();取扩展名EXE</p>
<p>[2]打开文件<br>CFile file(“C:HELLO.TXT”,CFile::modeRead);//只读方式打开<br>//CFile::modeRead可改为 CFile::modeWrite(只写),<br>//CFile::modeReadWrite(读写),CFile::modeCreate(新建)<br>例子：<br>{<br>CFile file;<br>file.Open(“C:HELLO.TXT”,CFile::modeCreate|Cfile::modeWrite);<br>.<br>.<br>.<br>}</p>
<p>[3]移动文件指针<br>file.Seek(100,CFile::begin);///从文件头开始往下移动100字节<br>file.Seek(-50,CFile::end);///从文件末尾往上移动50字节<br>file.Seek(-30,CFile::current);///从当前位置往上移动30字节<br>file.SeekToBegin();///移到文件头<br>file.SeekToEnd();///移到文件尾</p>
<p>[4]读写文件<br>读文件：<br>char buffer[1000];<br>file.Read(buffer,1000);<br>写文件：<br>CString string(“自强不息”);<br>file.Write(string,8);</p>
<p>[5]关闭文件<br>file.Close();</p>
<p>　　bWorking=finder.FindNextFile();<br>　　strFileTitle=finder.GetFileTitle();<br>　　}</p>
<p>　　2．文件的打开/保存对话框<br>　　让用户选择文件进行打开和存储操作时，就要用到文件打开/保存对话框。MFC的类CFileDialog用于实现这种功能。使用CFileDialog声明一个对象时，第一个BOOL型参数用于指定文件的打开或保存，当为TRUE时将构造一个文件打开对话框，为FALSE时构造一个文件保存对话框。<br>　　在构造CFileDialog对象时，如果在参数中指定了OFN_ALLOWMULTISELECT风格，则在此对话框中可以进行多选操作。此时要重点注意为此CFileDialog对象的m_ofn.lpstrFile分配一块内存，用于存储多选操作所返回的所有文件路径名，如果不进行分配或分配的内存过小就会导致操作失败。下面这段程序演示了文件打开对话框的使用方法。</p>
<p>　　CFileDialog mFileDlg(TRUE,NULL,NULL,OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_ALLOWMULTISELECT,<br>　　“All Files (<em>.</em>)|<em>.</em>||”,AfxGetMainWnd());<br>　　CString str(“ “,10000);<br>　　mFileDlg.m_ofn.lpstrFile=str.GetBuffer(10000);<br>　　str.ReleaseBuffer();<br>　　POSITION mPos=mFileDlg.GetStartPosition();<br>　　CString pathName(“ “,128);<br>　　CFileStatus status;<br>　　while(mPos!=NULL)<br>　　{<br>　　pathName=mFileDlg.GetNextPathName(mPos);<br>　　CFile::GetStatus( pathName, status );<br>　　}</p>
<p>　　3．文件的读写<br>　　文件的读写非常重要，下面将重点进行介绍。文件读写的最普通的方法是直接使用CFile进行，如文件的读写可以使用下面的方法：<br>　　//对文件进行读操作<br>　　<br>char sRead[2];<br>　　CFile mFile(_T(“user.txt”),CFile::modeRead);<br>　　if(mFile.GetLength()&lt;2)<br>　　return;<br>　　mFile.Read(sRead,2);<br>　　mFile.Close();<br>　　//对文件进行写操作<br>　　CFile mFile(_T(“user.txt “), CFile::modeWrite|CFile::modeCreate);<br>　　mFile.Write(sRead,2);<br>　　mFile.Flush();<br>　　mFile.Close();</p>
<p>　　虽然这种方法最为基本，但是它的使用繁琐，而且功能非常简单。我向你推荐的是使用CArchive，它的使用方法简单且功能十分强大。首先还是用CFile声明一个对象，然后用这个对象的指针做参数声明一个CArchive对象，你就可以非常方便地存储各种复杂的数据类型了。它的使用方法见下例。<br>　　<br>//对文件进行写操作<br>　　CString strTemp;<br>　　CFile mFile;<br>　　mFile.Open(“d:\dd\try.TRY”,CFile::modeCreate|CFile::modeNoTruncate|CFile::modeWrite);<br>　　CArchive ar(&amp;mFile,CArchive::store);<br>　　ar&lt;&lt;　　ar.Close();<br>　　mFile.Close();<br>　　//对文件进行读操作<br>　　CFile mFile;<br>　　if(mFile.Open(“d:\dd\try.TRY”,CFile::modeRead)==0)<br>　　return;<br>　　CArchive ar(&amp;mFile,CArchive::load);<br>　 　ar&gt;&gt;strTemp;<br>    　 ar.Close();<br>　　mFile.Close();</p>
<p>　　CArchive的 &lt;&lt; 和&gt;&gt; 操作符用于简单数据类型的读写，对于CObject派生类的对象的存取要使用ReadObject()和WriteObject()。使用CArchive的ReadClass()和WriteClass()还可以进行类的读写，如：<br>　　//存储CAboutDlg类<br>　　ar.WriteClass(RUNTIME_CLASS(CAboutDlg));<br>　　//读取CAboutDlg类<br>　　CRuntimeClass<em> mRunClass=ar.ReadClass();<br>　　//使用CAboutDlg类<br>　　CObject</em> pObject=mRunClass-&gt;CreateObject();<br>    　　((CDialog* )pObject)-&gt;DoModal();<br>　　虽然VC提供的文档/视结构中的文档也可进行这些操作，但是不容易理解、使用和管理，因此虽然很多VC入门的书上花费大量篇幅讲述文档/视结构，但我建议你最好不要使用它的文档。关于如何进行文档/视的分离有很多书介绍，包括非常著名的《Visual C++ 技术内幕》。<br>　　如果你要进行的文件操作只是简单的读写整行的字符串，我建议你使用CStdioFile，用它来进行此类操作非常方便，如下例。<br>　　CStdioFile mFile;<br>　　CFileException mExcept;<br>　　mFile.Open( “d:\temp\aa.bat”, CFile::modeWrite, &amp;mExcept);<br>　　CString string=”I am a string.”;<br>　　mFile.WriteString(string);<br>　　mFile.Close();</p>
<p>追加到原有txt文件尾</p>
<pre><code>mFile.Open(temptxt,CFile::modeCreate|CFile::modeWrite|CFile::modeNoTruncate);
</code></pre><p> if(mFile==NULL)<br>  return false;<br> mFile.SeekToEnd();<br> mFile.WriteString(s);</p>
<p> file.Close();<br>　4．临时文件的使用</p>
<p>　　正规软件经常用到临时文件，你经常可以会看到C:WindowsTemp目录下有大量的扩展名为tmp的文件，这些就是程序运行是建立的临时文件。临时文件的使用方法基本与常规文件一样，只是文件名应该调用函数GetTempFileName()获得。它的第一个参数是建立此临时文件的路径，第二个参数是建立临时文件名的前缀，第四个参数用于得到建立的临时文件名。得到此临时文件名以后，你就可以用它来建立并操作文件了，如：<br>　　char szTempPath[_MAX_PATH],szTempfile[_MAX_PATH];<br>　　GetTempPath(_MAX_PATH, szTempPath);<br>　　GetTempFileName(szTempPath,<em>T (“my</em>“),0,szTempfile);<br>　　CFile m_tempFile(szTempfile,CFile:: modeCreate|CFile:: modeWrite);<br>　　char m_char=’a’;<br>　　m_tempFile.Write(&amp;m_char,2);<br>　　m_tempFile.Close();<br>　　5．文件的复制、删除等<br>　　MFC中没有提供直接进行这些操作的功能，因而要使用SDK。SDK中的文件相关函数常用的有CopyFile()、CreateDirectory()、DeleteFile()、MoveFile()。它们的用法很简单，可参考MSDN。</p>
<p>1,判断文件是否存在<br>    access(filename,mode);<br>2,对于不同用途又不同的文件操作,其中API函数CreateFile()也是比较有用处理方式,对于巨型文件很合适的其他的楼上的大都说了,不重复了.</p>
<p>[1]显示对话框，取得文件名</p>
<p>CString FilePathName;<br>CFileDialog dlg(TRUE);///TRUE为OPEN对话框，FALSE为S<em>*</em>E AS对话框<br>if (dlg.DoModal() == IDOK)<br>    FilePathName=dlg.GetPathName();</p>
<p>相关信息：CFileDialog 用于取文件名的几个成员函数：<br>假如选择的文件是C:WINDOWSTEST.EXE<br>则(1)GetPathName();取文件名全称，包括完整路径。取回C:WINDOWSTEST.EXE<br>(2)GetFileTitle();取文件全名：TEST.EXE<br>(3)GetFileName();取回TEST<br>(4)GetFileExt();取扩展名EXE</p>
<p>[2]打开文件<br>CFile file(“C:HELLO.TXT”,CFile::modeRead);//只读方式打开<br>//CFile::modeRead可改为 CFile::modeWrite(只写),<br>//CFile::modeReadWrite(读写),CFile::modeCreate(新建)<br>例子：<br>{<br>CFile file;<br>file.Open(“C:HELLO.TXT”,CFile::modeCreate|Cfile::modeWrite);<br>.<br>.<br>.<br>}</p>
<p>[3]移动文件指针<br>file.Seek(100,CFile::begin);///从文件头开始往下移动100字节<br>file.Seek(-50,CFile::end);///从文件末尾往上移动50字节<br>file.Seek(-30,CFile::current);///从当前位置往上移动30字节<br>file.SeekToBegin();///移到文件头<br>file.SeekToEnd();///移到文件尾</p>
<p>[4]读写文件<br>读文件：<br>char buffer[1000];<br>file.Read(buffer,1000);<br>写文件：<br>CString string(“自强不息”);<br>file.Write(string,8);</p>
<p>[5]关闭文件<br>file.Close();</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/30/blog_md/MFC文件操作/" data-id="cj5qx8wef0001mov6ny7ed5l6" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/07/09/blog_md/C++文件操作/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">C++中的文件操作</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/30/blog_md/MFC文件操作/">MFC文件操作</a>
          </li>
        
          <li>
            <a href="/2017/07/09/blog_md/C++文件操作/">C++中的文件操作</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 liudonghai<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>